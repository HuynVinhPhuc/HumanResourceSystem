@using Syncfusion.Blazor.Charts

@if (IsVisible)
{
    <SfChart Title="Periodic Evaluation Scores" Width="100%">
        <ChartArea><ChartAreaBorder Width="0"></ChartAreaBorder></ChartArea>
        <ChartPrimaryXAxis ValueType="Syncfusion.Blazor.Charts.ValueType.DateTime" EdgeLabelPlacement="EdgeLabelPlacement.Shift">
            <ChartAxisMajorGridLines Width="0"></ChartAxisMajorGridLines>
        </ChartPrimaryXAxis>
        <ChartPrimaryYAxis Title="Score" Minimum="0" Maximum="10" Interval="1">
            <ChartAxisLineStyle Width="0"></ChartAxisLineStyle>
            <ChartAxisMajorTickLines Width="0"></ChartAxisMajorTickLines>
        </ChartPrimaryYAxis>
        <ChartTooltipSettings Enable="true"></ChartTooltipSettings>
        <ChartSeriesCollection>
            <ChartSeries DataSource="@SkillEvaluationChartData" Name="Technical Skills" XName="EvaluationDate" Width="2"
                         Opacity="1" YName="TechnicalSkillsScore" Type="ChartSeriesType.Line">
                <ChartMarker Visible="true" Width="7" Height="7" IsFilled="true" Shape="ChartShape.Circle">
                </ChartMarker>
            </ChartSeries>
            <ChartSeries DataSource="@SkillEvaluationChartData" Name="Communication Skills" XName="EvaluationDate" Width="2"
                         Opacity="1" YName="CommunicationSkillsScore" Type="ChartSeriesType.Line">
                <ChartMarker Visible="true" Width="6" IsFilled="true" Height="6" Shape="ChartShape.Triangle">
                </ChartMarker>
            </ChartSeries>
            <ChartSeries DataSource="@SkillEvaluationChartData" Name="Teamwork Skills" XName="EvaluationDate" Width="2"
                         Opacity="1" YName="TeamworkSkillsScore" Type="ChartSeriesType.Line">
                <ChartMarker Visible="true" Width="7" IsFilled="true" Height="7" Shape="ChartShape.Diamond">
                </ChartMarker>
            </ChartSeries>
            <ChartSeries DataSource="@SkillEvaluationChartData" Name="Problem Solving Skills" XName="EvaluationDate" Width="2"
                         Opacity="1" YName="ProblemSolvingSkillsScore" Type="ChartSeriesType.Line">
                <ChartMarker Visible="true" Width="5" IsFilled="true" Height="5" Shape="ChartShape.Rectangle">
                </ChartMarker>
            </ChartSeries>
            <ChartSeries DataSource="@SkillEvaluationChartData" Name="Work Ethic" XName="EvaluationDate" Width="2"
                         Opacity="1" YName="WorkEthicScore" Type="ChartSeriesType.Line">
                <ChartMarker Visible="true" Width="7" IsFilled="true" Height="7" Shape="ChartShape.Pentagon">
                </ChartMarker>
            </ChartSeries>
        </ChartSeriesCollection>
        <ChartLegendSettings EnableHighlight="true"></ChartLegendSettings>
    </SfChart>
}

@code {
    public List<PeriodicEvaluation> PeriodicEvaluations { get; set; } = new();
    [Parameter] public bool IsVisible { get; set; } = true;

    public void OpenPeriodicEvaluationStatistical()
    {
        IsVisible = true;
        StateHasChanged();
    }

    public void ClosePeriodicEvaluationStatistical()
    {
        IsVisible = false;
        StateHasChanged();
    }

    protected async override Task OnInitializedAsync()
    {
        await LoadPeriodicEvaluations();
        CalculateMonthlyAverages();
        allState.Action += StateHasChanged;
    }

    private async Task LoadPeriodicEvaluations() => PeriodicEvaluations = await periodicEvaluationService.GetAll(SupportConstants.PeriodicEvaluationBaseUrl);

    private void CalculateMonthlyAverages()
    {
        // Tạo danh sách 12 tháng trong năm
        var twelveMonths = Enumerable.Range(0, 12)
            .Select(i => DateTime.Now.AddMonths(-i))
            .Select(date => new DateTime(date.Year, date.Month, 1))
            .ToList();

        // Nhóm đánh giá theo tháng
        var groupedEvaluations = PeriodicEvaluations
            .GroupBy(e => new DateTime(e.EvaluationDate.Year, e.EvaluationDate.Month, 1))
            .Select(g => new SkillEvaluationData
                {
                    EvaluationDate = g.Key,
                    TechnicalSkillsScore = Math.Round(g.Average(e => e.TechnicalSkillsScore), 1),
                    CommunicationSkillsScore = Math.Round(g.Average(e => e.CommunicationSkillsScore), 1),
                    TeamworkSkillsScore = Math.Round(g.Average(e => e.TeamworkSkillsScore), 1),
                    ProblemSolvingSkillsScore = Math.Round(g.Average(e => e.ProblemSolvingSkillsScore), 1),
                    WorkEthicScore = Math.Round(g.Average(e => e.WorkEthicScore), 1)
                })
            .ToList();

        // Đảm bảo rằng có đủ 12 tháng trong danh sách
        foreach (var month in twelveMonths)
        {
            // Kiểm tra xem tháng này đã có trong danh sách groupedEvaluations chưa
            if (!groupedEvaluations.Any(g => g.EvaluationDate.Year == month.Year && g.EvaluationDate.Month == month.Month))
            {
                groupedEvaluations.Add(new SkillEvaluationData
                    {
                        EvaluationDate = month,
                        TechnicalSkillsScore = 0,
                        CommunicationSkillsScore = 0,
                        TeamworkSkillsScore = 0,
                        ProblemSolvingSkillsScore = 0,
                        WorkEthicScore = 0
                    });
            }
        }

        // Sắp xếp lại danh sách theo thời gian
        groupedEvaluations = groupedEvaluations.OrderBy(g => g.EvaluationDate).ToList();

        SkillEvaluationChartData = groupedEvaluations;
    }

    public class SkillEvaluationData
    {
        public DateTime EvaluationDate { get; set; }
        public double TechnicalSkillsScore { get; set; }
        public double CommunicationSkillsScore { get; set; }
        public double TeamworkSkillsScore { get; set; }
        public double ProblemSolvingSkillsScore { get; set; }
        public double WorkEthicScore { get; set; }
    }

    public List<SkillEvaluationData> SkillEvaluationChartData { get; set; } = new List<SkillEvaluationData>();

    public void Dispose() => allState.Action -= StateHasChanged;
}

